<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Пак Александр Владимирович, Экзамен C++, 8 июля 2020</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <style type="text/css">
    .codeblock
    {
      background: #e0e0e0;
      border: solid 1px black;
      padding: 5px;
      font-family: monospace;
    }
    .codein
    {
      font-family: monospace;
    }
    pre { margin: 0; }
    td.numbers {text-align: right;}
    td.names {text-align: left;}
    td {text-align: center;}
    tr.odd {background-color: #e0e0e0;}
    img.centered {display: block; margin-left: auto; margin-right: auto;}
    sup:target {background-color: #def;}
    li:target {background-color: #def;}
    ol li { list-style-type: lower-russian; }
    p {font-family:sans-serif; font-size: 12pt;}
    p {font-family:'Liberation Sans', sans-serif; font-size: 12pt;}
    li {font-family:'Liberation Sans', sans-serif; font-size: 12pt;}
    h2 {font-family:'Liberation Sans', sans-serif;}
    h3 {font-family:'Liberation Sans', sans-serif;}
    h4 {font-family:'Liberation Sans', sans-serif;}
    </style>
  </head>
  <body>
<h2>Пак Александр Владимирович</h2>
<h2>Вопрос 1</h2>
<p>Даны три инструкции:</p><div class="codeblock"><pre>            lea     rdi, [rdi + 8]
            mov     rdi, [rdi + 8]
            add     rdi, 8</pre></div>
<p>Опишите, что делает каждая из них. Чем поведение <span class="codein">lea</span> отличается от <span class="codein">mov</span>? Чем поведение <span class="codein">lea</span> отличается от <span class="codein">add</span>.</p>
<h2>Вопрос 2</h2>
<p>Вам дана документация к инструкции <span class="codein">neg</span>: <a href="https://www.felixcloutier.com/x86/neg">https://www.felixcloutier.com/x86/neg</a>. Что нужно написать на месте ???, чтобы переход на метку <span class="codein">was_zero</span> осуществлялся, когда <span class="codein">rax == 0</span>?</p><div class="codeblock"><pre>            neg		rax
            j???	was_zero</pre></div>
<h2>Вопрос 3</h2>
<p>Напишите (на ассемблере) функцию вычисляющую <span class="codein">N</span>'ое число фибоначчи (mod 2<sup>64</sup>). <span class="codein">fib(0) = 0</span>, <span class="codein">fib(1) = 1</span>, <span class="codein">fib(n) = fib(n - 1) + fib(n - 2)</span>. Считайте, что при входе <span class="codein">N</span> записано в регистре <span class="codein">rdi</span>. При выходе ответ должен быть записан в <span class="codein">rax</span>.</p><h2>Вопрос 4</h2>
<p>Что такое соглашения вызова функций? Какие соглашения вызова функций вы знаете? Чем они отличаются друг от друга?</p><h2>Вопрос 5</h2>
<p>Пусть у нас есть функция <span class="codein">void foo(int, void*)</span>. Какой код необходимо сгенерить компилятору, чтобы вызвать эту функцию <span class="codein">f(42, nullptr)</span>, предполагая что программа компилируется под 64-битный Linux?</p><h2>Вопрос 6</h2>
<p>Есть ли какое-то объяснение почему в 32-битном режиме huge pages имеют размер 4 МБ, а в 64-битном — 2 МБ и 1 ГБ?</p><h2>Вопрос 7</h2>
<p>Предполагая что программа скомпилирована для Linux 64-bit, чему равны <span class="codein">sizeof</span> и <span class="codein">alignof</span> следующих структур? Объясните почему.</p><div class="codeblock"><pre>struct s1
{
    int a;
    int b;
};

struct s2
{
    char a;
    int b;
};

struct s3
{
    int a;
    char b;
};

struct s4
{
    char a;
    int b;
    char c;
};

struct s5
{};

struct s6
{
    s5 x, y, z;
};

struct s7 : s5
{};

struct s8 : s5, s7
{};

struct t10
{
    virtual void foo();
};

struct t11 : t10
{
    virtual void bar();
};

struct t12 : virtual t10
{};</pre></div>
<h2>Вопрос 8</h2>
<p>Пусть есть две программы:</p><div class="codeblock"><pre>// 1
void f(int) {}
void f(signed int) {}
void f(unsigned int) {}</pre></div>
<div class="codeblock"><pre>// 2
void f(char) {}
void f(signed char) {}
void f(unsigned char) {}</pre></div>
<p>Компилируются ли они или нет? Если нет, то почему?</p><h2>Вопрос 9</h2>
<p>Правда ли, что для floating-point чисел a != b влечёт (a - b) != 0?</p><h2>Вопрос 10</h2>
<p>Пусть <span class="codein">x</span> — переменная, объявленная как <span class="codein">int x</span>.</p>

<p>Корректные ли это выражения? Если нет, то почему?</p>

<p><ol><li><span class="codein">x = 2</span></li>
<li><span class="codein">2 = x</span></li>
<li><span class="codein">++++x</span></li>
<li><span class="codein">x++++</span></li>
<li><span class="codein">++x++</span></li>
<li><span class="codein">x = 2 = 3</span></li>
<li><span class="codein">x += 2 += 3</span></li>
<li><span class="codein">(x += 2) += 3</span></li>
<li><span class="codein">&amp; &amp;x</span></li>
<li><span class="codein">*&amp;x</span></li>
</ol></p><h2>Вопрос 11</h2>
<p>Дана программа, состоящая из следующих файлов:</p><div class="codeblock"><pre>// main.cpp
#include "f.h"

int main()
{
    f();
    g();
}</pre></div>
<div class="codeblock"><pre>// f.h
#pragma once
#include &lt;iostream&gt;

void f()
{
    std::cout &lt;&lt; "hello";
}</pre></div>
<div class="codeblock"><pre>// g.cpp
#include "f.h"

void g()
{
    std::cout &lt;&lt; ' ';
    f();
}</pre></div>
<p>Скомпилируется ли данная программа? Если да, то что она выведет? Если нет, то какие в ней ошибки и как их можно исправить?</p><h2>Вопрос 12</h2>
<p>Пусть есть следующий заголовочный файл:</p><div class="codeblock"><pre>// numbers.h
static int val;

inline int next()
{
    return val++;
}</pre></div>
<p>Какие вы видите ошибки в этом файле? Как их можно исправить?</p><h2>Вопрос 13</h2>
<p>В чем разница между директивами препроцессора #if и #ifdef?</p><h2>Вопрос 14</h2>
<p>Рассмотрим следующий класс mystring:</p><div class="codeblock"><pre>// mystring.h
#pragma once
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;

struct mystring
{
    mystring(char const* text);
    mystring(mystring const&amp; other);

    mystring&amp; operator=(mystring const&amp; rhs);

    ~mystring();

private:
    char* data_;
    size_t size_;
    size_t capacity_;
};</pre></div>
<div class="codeblock"><pre>// mystring.cpp
#include "mystring.h"

mystring::mystring(char const* text)
    : size_(strlen(text))
    , capacity_(size_)
{
    data_ = static_cast&lt;char*&gt;(operator new(size_ + 1));
    memcpy(data_, text, size_ + 1);
}

mystring::mystring(mystring const&amp; other)
    : data_(static_cast&lt;char*&gt;(operator new(other.size_ + 1)))
    , size_(other.size_)
    , capacity_(other.size_)
{
    memcpy(data_, other.data_, other.size_ + 1);
}

mystring&amp; mystring::operator=(mystring const&amp; rhs)
{
    data_ = static_cast&lt;char*&gt;(operator new(rhs.size_ + 1));
    memcpy(data_, rhs.data_, rhs.size_ + 1);
    size_ = rhs.size_;
    capacity_ = rhs.size_;
    return *this;
}

mystring::~mystring()
{
    operator delete(data_);
}</pre></div>
<p>Почему конструктор копирования и оператор присваивания, генерируемые автоматически, не подошли бы для данного класса? Корректно ли они реализованы в приведённом примере? Если нет — напишите исправленную версию.</p><h2>Вопрос 15</h2>
<p>Будем считать, что правильный оператор [], это такой, который ведет себя как [] у массива. Объясните почему такие операторы [] у mystring неправильные:</p><p><ol><li><span class="codein">char operator[](size_t i);</span> (одной перегрузкой)</li>
<li><span class="codein">char&amp; operator[](size_t i) const;</span> (одной перегрузкой)</li></ol></p><p>Напишите правильный набор перегрузок для оператор [] у класса mystring.</p><h2>Вопрос 16</h2>
<p>Пусть есть следующая программа:</p><div class="codeblock"><pre>#include &lt;iostream&gt;

struct base
{
   virtual void foo();
};

struct derived : base
{
   void foo() override;
};

void derived::foo()
{
   std::cout &lt;&lt; "derived::foo\n";
   // call foo() in base
}</pre></div>
<p>Что нужно написать на месте комментария, чтобы вызвать foo() из базового класса?</p><h2>Вопрос 17</h2>
<p>Рассмотрим следующую программу:</p><div class="codeblock"><pre>struct base
{
protected:
    int x;
};

struct derived : base
{
    void foo(base&amp; a, derived&amp; b)
    {
        x; // 1
        a.x; // 2
        b.x; // 3
    }
};</pre></div>
<p>Какие из трех обращений разрешены, а какие нет? Исходя из этого сформулируйте правило, что означает модификатор доступа protected. Почему было бы плохо, если бы правила языка были сформулированны так, что все три обращения (1, 2, 3) были разрешены?</p><h2>Вопрос 18</h2>
<div class="codeblock"><pre>struct base
{
    virtual ~base();
};

struct derived : virtual base
{};

void foo(base* b)
{
    static_cast&lt;derived*&gt;(b); // (1)
    dynamic_cast&lt;derived*&gt;(b); // (2)
}</pre></div>
<p>Компилируются ли (1) и (2)? Почему?</p><h2>Вопрос 19</h2>
<p><ol><li>Можно ли бросать исключения из деструктора? Если да, приведите пример.</li>
<li>Можно ли бросать исключения из конструктора? Если да, приведите пример.</li></ol></p><h2>Вопрос 20</h2>
<p>Почему такая реализации оператора присваивания у класса mystring является ошибочной?</p><div class="codeblock"><pre>mystring&amp; mystring::operator=(mystring const&amp; rhs)
{
    operator delete(data_);
    size_ = rhs.size_;
    capacity_ = size_;
    data_ = static_cast&lt;char*&gt;(operator new(rhs.size_ + 1));
    memcpy(data_, rhs.data_, rhs.size_ + 1);
    return *this;
}</pre></div>
<h2>Вопрос 21</h2>
<p>Напишите функцию <span class="codein">void erase_strong(std::vector&lt;T&gt;&amp; v, typename std::vector&lt;T&gt;::const_iterator pos)</span>, которая удаляет элемент на позиции pos из вектора v и удовлетворяет строгой гарантии безопасности исключений.</p><h2>Вопрос 22</h2>
<p>Что такое small-object оптимизация? Приведите примеры. В каких случаях она даёт выигрыш? В каких случаях она даёт проигрыш?</p><h2>Вопрос 23</h2>
<p>Напишите шаблонный класс (и, если нужно, специализации к нему), который позволяет сравнить два типа на совпадение. То есть:</p><div class="codeblock"><pre>is_same&lt;int, int&gt;::value == true
is_same&lt;int, float&gt;::value == false
is_same&lt;char*, mytype&gt;::value == false
is_same&lt;char, char const&gt;::value == false
is_same&lt;vector&lt;int&gt;*, vector&lt;int&gt;*&gt;::value == true</pre></div>
<h2>Вопрос 24</h2>
<p>Что такое зависимые имена? Что означает ключевое слово typename стоящее перед зависимым именем? Что означает ключевое слово template стоящее перед зависимым именем?</p><h2>Вопрос 25</h2>
<p>Что такое two-phase name lookup? Прведите пример программы, коротая либо компилируется либо нет в зависимости от того поддерживает компилятор two-phase name lookup или нет.</p><h2>Вопрос 26</h2>
<p>Что такое анонимные неймпейсы? Для чего они нужны? Можно ли их писать в хедер файлах?</p>  </body>
</html>