<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Морев Савва Игоревич, Экзамен C++, 8 июля 2020</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <style type="text/css">
    .codeblock
    {
      background: #e0e0e0;
      border: solid 1px black;
      padding: 5px;
      font-family: monospace;
    }
    .codein
    {
      font-family: monospace;
    }
    pre { margin: 0; }
    td.numbers {text-align: right;}
    td.names {text-align: left;}
    td {text-align: center;}
    tr.odd {background-color: #e0e0e0;}
    img.centered {display: block; margin-left: auto; margin-right: auto;}
    sup:target {background-color: #def;}
    li:target {background-color: #def;}
    ol li { list-style-type: lower-russian; }
    p {font-family:sans-serif; font-size: 12pt;}
    p {font-family:'Liberation Sans', sans-serif; font-size: 12pt;}
    li {font-family:'Liberation Sans', sans-serif; font-size: 12pt;}
    h2 {font-family:'Liberation Sans', sans-serif;}
    h3 {font-family:'Liberation Sans', sans-serif;}
    h4 {font-family:'Liberation Sans', sans-serif;}
    </style>
  </head>
  <body>
<h2>Морев Савва Игоревич</h2>
<h2>Вопрос 1</h2>
<p>Пусть регистр <span class="codein">rax</span> содержит значение 5181410645718736537 (0x47e81187ad7e1e99 в шестнадцатеричной записи). Какие в этом случае значения содержат регистры <span class="codein">eax</span>, <span class="codein">ax</span>, <span class="codein">al</span>, <span class="codein">ah</span>?</p><h2>Вопрос 2</h2>
<p>Какие значения получат регистры <span class="codein">bl</span>, <span class="codein">cl</span> после исполнения функции <span class="codein">foo</span>?</p>
<div class="codeblock"><pre>somevar:    dw 0

foo:
            mov ax, 0x1234
            mov [somevar], ax
            
            mov bl, [somevar]
            mov cl, [somevar + 1]

            ret</pre></div>
<h2>Вопрос 3</h2>
<p>Вам дана документация к инструкции <span class="codein">neg</span>: <a href="https://www.felixcloutier.com/x86/neg">https://www.felixcloutier.com/x86/neg</a>. Что нужно написать на месте ???, чтобы переход на метку <span class="codein">was_zero</span> осуществлялся, когда <span class="codein">rax == 0</span>?</p><div class="codeblock"><pre>            neg		rax
            j???	was_zero</pre></div>
<h2>Вопрос 4</h2>
<p>Что такое соглашения вызова функций? Какие соглашения вызова функций вы знаете? Чем они отличаются друг от друга?</p><h2>Вопрос 5</h2>
<p>Рассмотрим такой код:</p><div class="codeblock"><pre>int g(int a, int b);

int f(int a)
{
   return g(42, a);
}</pre></div>
<p>Можно было бы предположить, что для <span class="codein">f</span> будет сгенерён следующий код:</p>
<div class="codeblock"><pre>f:
           mov		esi, edi
           mov		edi, 42
           call	g
           ret</pre></div>
<p>Однако компиляторы заменяют <span class="codein">call</span>/<span class="codein">ret</span>, на один <span class="codein">jmp</span>:</p><div class="codeblock"><pre>f:
           mov		esi, edi
           mov		edi, 42
           jmp		g</pre></div>
<p>Такая оптимизация называется <i>sibling call optimization</i>. Каким свойствам должны удовлетворять функции <span class="codein">f</span> и <span class="codein">g</span>, чтобы такая оптимизация была возможна? Предполагайте что программа скомпилирована для Linux 64-bit.</p><h2>Вопрос 6</h2>
<p>Есть ли какое-то объяснение почему в 32-битном режиме huge pages имеют размер 4 МБ, а в 64-битном — 2 МБ и 1 ГБ?</p><h2>Вопрос 7</h2>
<p>Предполагая что программа скомпилирована для Linux 64-bit, чему равны <span class="codein">sizeof</span> и <span class="codein">alignof</span> следующих структур? Объясните почему.</p><div class="codeblock"><pre>struct s1
{
    int a;
    int b;
};

struct s2
{
    char a;
    int b;
};

struct s3
{
    int a;
    char b;
};

struct s4
{
    char a;
    int b;
    char c;
};

struct s5
{};

struct s6
{
    s5 x, y, z;
};

struct s7 : s5
{};

struct s8 : s5, s7
{};

struct t10
{
    virtual void foo();
};

struct t11 : t10
{
    virtual void bar();
};

struct t12 : virtual t10
{};</pre></div>
<h2>Вопрос 8</h2>
<p><ol><li>Чему равен минимальный <span class="codein">float</span> строго больший <span class="codein">1.f</span>?</li>
<li>Чему равен минимальный <span class="codein">float</span> строго больший <span class="codein">2.f</span>?</li></ol></p>
<h2>Вопрос 9</h2>
<p>(если в этом задании отвечаете нет, приведите контрпример)
    
    <ol><li>Правда ли, что для любых floating-point a и b верно a + b == b + a?</li>
    <li>Правда ли, что для любых floating-point a, b и c верно a + (b + c) == (a + b) + c?</li>
    <li>Правда ли, что для любого floating-point a верно 1 * a == a?</li>
    <li>Правда ли, что для любого floating-point a верно 0 * a == 0?</li>
    <li>Правда ли, что для любого floating-point a верно a - a == 0?</li></ol></p><h2>Вопрос 10</h2>
<p>Пусть x — переменная, объявленная как int x.</p>

<p>Корректные ли это выражения? Если нет, то почему?</p>

<p><ol><li><span class="codein">x = 2</span></li>
<li><span class="codein">2 = x</span></li>
<li><span class="codein">++++x</span></li>
<li><span class="codein">x++++</span></li>
<li><span class="codein">++x++</span></li>
<li><span class="codein">x = 2 = 3</span></li>
<li><span class="codein">x += 2 += 3</span></li>
<li><span class="codein">(x += 2) += 3</span></li>
<li><span class="codein">&amp; &amp;x</span></li>
<li><span class="codein">*&amp;x</span></li>
</ol></p><h2>Вопрос 11</h2>
<p>Пусть есть следующий заголовочный файл:</p><div class="codeblock"><pre>// sum.h
static int sum(int a, int b)
{
    return a + b;
}</pre></div>
<p>Какие вы видите ошибки в этом файле? Как их можно исправить?</p><h2>Вопрос 12</h2>
<p>Приведите пример программы, приводящий к ошибке на этапе препроцесcирования.</p><h2>Вопрос 13</h2>
<p>В чем разница между директивами препроцессора #if и #ifdef?</p><h2>Вопрос 14</h2>
<p>В чём разница между парами malloc/free, new T/delete p, operator new/operator delete?</p><h2>Вопрос 15</h2>
<p>Что означают модификаторы доступа public и private?</p><h2>Вопрос 16</h2>
<p>Пусть есть следующая программа:</p><div class="codeblock"><pre>#include &lt;iostream&gt;

struct base
{
   virtual void foo();
};

struct derived : base
{
   void foo() override;
};

void derived::foo()
{
   std::cout &lt;&lt; "derived::foo\n";
   // call foo() in base
}</pre></div>
<p>Что нужно написать на месте комментария, чтобы вызвать foo() из базового класса?</p><h2>Вопрос 17</h2>
<p>Рассмотрим следующую программу:</p><div class="codeblock"><pre>struct base
{
protected:
    int x;
};

struct derived : base
{
    void foo(base&amp; a, derived&amp; b)
    {
        x; // 1
        a.x; // 2
        b.x; // 3
    }
};</pre></div>
<p>Какие из трех обращений разрешены, а какие нет? Исходя из этого сформулируйте правило, что означает модификатор доступа protected. Почему было бы плохо, если бы правила языка были сформулированны так, что все три обращения (1, 2, 3) были разрешены?</p><h2>Вопрос 18</h2>
<p>Может ли деструктор быть абстрактным? Если да, приведите пример программы, в которой содержится и используется абстрактный деструктор.</p><h2>Вопрос 19</h2>
<div class="codeblock"><pre>#include &lt;iostream&gt;

struct base
{
    virtual char const* msg() const
    {
        return "base";
    }
};

struct derived : base
{
    char const* msg() const override
    {
        return "derived";
    }
};

void f()
{
    throw derived();
}

int main()
{
    try
    {
        f();
    }
    catch (base b)
    {
        std::cout &lt;&lt; b.msg();
    }
}</pre></div>
<p>Что выводит данная программа? Почему? Как нужно её исправить, чтобы выводилось "derived"?</p><h2>Вопрос 20</h2>
<div class="codeblock"><pre>#include &lt;iostream&gt;

struct base
{
    virtual char const* msg() const
    {
        return "base";
    }
};

struct derived : base
{
    char const* msg() const
    {
        return "derived";
    }
};

void f()
{
    throw derived();
}

void g()
{
    try
    {
        f();
    }
    catch (base const&amp; b)
    {
        std::cout &lt;&lt; b.msg() &lt;&lt; '\n';
        throw b;
    }
}

int main()
{
    try
    {
        g();
    }
    catch (base const&amp; b)
    {
        std::cout &lt;&lt; b.msg();
    }
}
</pre></div>
<p>Что выводит данная программа? Почему? Как нужно её исправить, чтобы выводилось "derived\nderived"?</p><h2>Вопрос 21</h2>
<p>Почему такая реализации оператора присваивания у класса mystring является ошибочной?</p><div class="codeblock"><pre>mystring&amp; mystring::operator=(mystring const&amp; rhs)
{
    operator delete(data_);
    size_ = rhs.size_;
    capacity_ = size_;
    data_ = static_cast&lt;char*&gt;(operator new(rhs.size_ + 1));
    memcpy(data_, rhs.data_, rhs.size_ + 1);
    return *this;
}</pre></div>
<h2>Вопрос 22</h2>
<p>Что такое copy-on-write оптимизация? Приведите примеры. В каких случаях она даёт выигрыш? В каких случаях она даёт проигрыш?</p><h2>Вопрос 23</h2>
<p>Напишите шаблонный класс (и, если нужно, специализации к нему), который позволяет получить тип элемента у многомерного массива. В случае если передан не массив верните тип без изменения. То есть:</p><div class="codeblock"><pre>element_type&lt;int [10]&gt;::type == int
element_type&lt;float [5][6]&gt;::type == float
element_type&lt;double [5][6][7]&gt;::type == double
element_type&lt;int* [5]&gt;::type == int*
element_type&lt;int&gt;::type == int
element_type&lt;int*&gt;::type == int*</pre></div>
<h2>Вопрос 24</h2>
<p>Пусть необходимо реализовать функцию void f(T* data, size_t size) двумя способами в зависимости от того, является ли тип T знаковым или беззнаковым выбираемый во время компиляции программы.</p>

<p>Напишите реализацию такой функции используя
<ol><li>SFINAE</li>
<li>tag-dispathing</li></ol></p><h2>Вопрос 25</h2>
<p>Что такое зависимые имена? Что означает ключевое слово typename стоящее перед зависимым именем? Что означает ключевое слово template стоящее перед зависимым именем?</p><h2>Вопрос 26</h2>
<p>Что такое анонимные неймпейсы? Для чего они нужны? Можно ли их писать в хедер файлах?</p>  </body>
</html>