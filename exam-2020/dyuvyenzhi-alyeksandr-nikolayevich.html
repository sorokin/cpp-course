<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Дювенжи Александр Николаевич, Экзамен C++, 8 июля 2020</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <style type="text/css">
    .codeblock
    {
      background: #e0e0e0;
      border: solid 1px black;
      padding: 5px;
      font-family: monospace;
    }
    .codein
    {
      font-family: monospace;
    }
    pre { margin: 0; }
    td.numbers {text-align: right;}
    td.names {text-align: left;}
    td {text-align: center;}
    tr.odd {background-color: #e0e0e0;}
    img.centered {display: block; margin-left: auto; margin-right: auto;}
    sup:target {background-color: #def;}
    li:target {background-color: #def;}
    ol li { list-style-type: lower-russian; }
    p {font-family:sans-serif; font-size: 12pt;}
    p {font-family:'Liberation Sans', sans-serif; font-size: 12pt;}
    li {font-family:'Liberation Sans', sans-serif; font-size: 12pt;}
    h2 {font-family:'Liberation Sans', sans-serif;}
    h3 {font-family:'Liberation Sans', sans-serif;}
    h4 {font-family:'Liberation Sans', sans-serif;}
    </style>
  </head>
  <body>
<h2>Дювенжи Александр Николаевич</h2>
<h2>Вопрос 1</h2>
<p>Пусть регистр <span class="codein">rax</span> содержит значение 3004560127822702307 (0x29b25784752ca6e3 в шестнадцатеричной записи). Какие в этом случае значения содержат регистры <span class="codein">eax</span>, <span class="codein">ax</span>, <span class="codein">al</span>, <span class="codein">ah</span>?</p><h2>Вопрос 2</h2>
<p>Какие значения получат регистры <span class="codein">bl</span>, <span class="codein">cl</span> после исполнения функции <span class="codein">foo</span>?</p>
<div class="codeblock"><pre>somevar:    dw 0

foo:
            mov ax, 0x1234
            mov [somevar], ax
            
            mov bl, [somevar]
            mov cl, [somevar + 1]

            ret</pre></div>
<h2>Вопрос 3</h2>
<p>Вам дана документация к инструкции <span class="codein">neg</span>: <a href="https://www.felixcloutier.com/x86/neg">https://www.felixcloutier.com/x86/neg</a>. Что нужно написать на месте ???, чтобы переход на метку <span class="codein">was_zero</span> осуществлялся, когда <span class="codein">rax == 0</span>?</p><div class="codeblock"><pre>            neg		rax
            j???	was_zero</pre></div>
<h2>Вопрос 4</h2>
<p>Что такое соглашения вызова функций? Какие соглашения вызова функций вы знаете? Чем они отличаются друг от друга?</p><h2>Вопрос 5</h2>
<p>Рассмотрим такой код:</p><div class="codeblock"><pre>int g(int a, int b);

int f(int a)
{
   return g(42, a);
}</pre></div>
<p>Можно было бы предположить, что для <span class="codein">f</span> будет сгенерён следующий код:</p>
<div class="codeblock"><pre>f:
           mov		esi, edi
           mov		edi, 42
           call	g
           ret</pre></div>
<p>Однако компиляторы заменяют <span class="codein">call</span>/<span class="codein">ret</span>, на один <span class="codein">jmp</span>:</p><div class="codeblock"><pre>f:
           mov		esi, edi
           mov		edi, 42
           jmp		g</pre></div>
<p>Такая оптимизация называется <i>sibling call optimization</i>. Каким свойствам должны удовлетворять функции <span class="codein">f</span> и <span class="codein">g</span>, чтобы такая оптимизация была возможна? Предполагайте что программа скомпилирована для Linux 64-bit.</p><h2>Вопрос 6</h2>
<p>Есть ли какое-то объяснение почему в 32-битном режиме huge pages имеют размер 4 МБ, а в 64-битном — 2 МБ и 1 ГБ?</p><h2>Вопрос 7</h2>
<p>Предполагая что программа скомпилирована для Linux 64-bit, чему равны <span class="codein">sizeof</span> и <span class="codein">alignof</span> следующих структур? Объясните почему.</p><div class="codeblock"><pre>struct s1
{
    int a;
    int b;
};

struct s2
{
    char a;
    int b;
};

struct s3
{
    int a;
    char b;
};

struct s4
{
    char a;
    int b;
    char c;
};

struct s5
{};

struct s6
{
    s5 x, y, z;
};

struct s7 : s5
{};

struct s8 : s5, s7
{};

struct t10
{
    virtual void foo();
};

struct t11 : t10
{
    virtual void bar();
};

struct t12 : virtual t10
{};</pre></div>
<h2>Вопрос 8</h2>
<p><ol><li>Чему равен минимальный <span class="codein">double</span> строго больший <span class="codein">1.</span>?</li>
<li>Чему равен минимальный <span class="codein">double</span> строго больший <span class="codein">2.</span>?</li></ol></p>
<h2>Вопрос 9</h2>
<p>Правда ли, что для floating-point чисел a != b влечёт (a - b) != 0?</p><h2>Вопрос 10</h2>
<p>Пусть x — переменная, объявленная как int x.</p>

<p>Корректные ли это выражения? Если нет, то почему?</p>

<p><ol><li><span class="codein">x = 2</span></li>
<li><span class="codein">2 = x</span></li>
<li><span class="codein">++++x</span></li>
<li><span class="codein">x++++</span></li>
<li><span class="codein">++x++</span></li>
<li><span class="codein">x = 2 = 3</span></li>
<li><span class="codein">x += 2 += 3</span></li>
<li><span class="codein">(x += 2) += 3</span></li>
<li><span class="codein">&amp; &amp;x</span></li>
<li><span class="codein">*&amp;x</span></li>
</ol></p><h2>Вопрос 11</h2>
<p>Пусть есть следующий заголовочный файл:</p><div class="codeblock"><pre>// numbers.h
static int val;

inline int next()
{
    return val++;
}</pre></div>
<p>Какие вы видите ошибки в этом файле? Как их можно исправить?</p><h2>Вопрос 12</h2>
<p>Приведите пример программы, приводящий к</p>

<p><ol><li>ошибке трансляции из-за ссылки на необъявленную функцию</li>
<li>ошибке линковки из-за ссылки на неопределенную функцию</li>
<li>ошибке трансляции из-за двойного определения функции</li>
<li>ошибке линковки из-за двойного определения функции</li></ol></p><h2>Вопрос 13</h2>
<p>Приведите пример программы, приводящий к ошибке на этапе препроцесcирования.</p><h2>Вопрос 14</h2>
<p>Будем считать, что правильный оператор [], это такой, который ведет себя как [] у массива. Объясните почему такие операторы [] у mystring неправильные:</p><p><ol><li><span class="codein">char operator[](size_t i);</span> (одной перегрузкой)</li>
<li><span class="codein">char&amp; operator[](size_t i) const;</span> (одной перегрузкой)</li></ol></p><p>Напишите правильный набор перегрузок для оператор [] у класса mystring.</p><h2>Вопрос 15</h2>
<p>Что означают модификаторы доступа public и private?</p><h2>Вопрос 16</h2>
<p>Пусть есть следующая программа:</p><div class="codeblock"><pre>#include &lt;iostream&gt;

struct base
{
   virtual void foo();
};

struct derived : base
{
   void foo() override;
};

void derived::foo()
{
   std::cout &lt;&lt; "derived::foo\n";
   // call foo() in base
}</pre></div>
<p>Что нужно написать на месте комментария, чтобы вызвать foo() из базового класса?</p><h2>Вопрос 17</h2>
<p>Корректная ли это программа? Если корректная, то, что она выводит? Если некорректная, то, в чём заключается ошибка?</p><div class="codeblock"><pre>#include &lt;iostream&gt;

struct base
{
    base()
    {
        f();
    }
    
    void f()
    {
        g();
    }
    
    virtual void g() = 0;
};

struct derived : base
{
    void g()
    {
        std::cout &lt;&lt; "hello\n";
    }
};

int main()
{
    derived d;
}</pre></div>
<p>Почему программа выше и программа ниже ведут себя по-разному?</p><div class="codeblock"><pre>#include &lt;iostream&gt;

struct base
{
    base()
    {
        g();
    }
    
    virtual void g() = 0;
};

struct derived : base
{
    void g()
    {
        std::cout &lt;&lt; "hello\n";
    }
};

int main()
{
    derived d;
}</pre></div>
<h2>Вопрос 18</h2>
<p>Может ли деструктор быть абстрактным? Если да, приведите пример программы, в которой содержится и используется абстрактный деструктор.</p><h2>Вопрос 19</h2>
<div class="codeblock"><pre>#include &lt;iostream&gt;

struct base
{
    virtual char const* msg() const
    {
        return "base";
    }
};

struct derived : base
{
    char const* msg() const override
    {
        return "derived";
    }
};

void f()
{
    throw derived();
}

int main()
{
    try
    {
        f();
    }
    catch (base b)
    {
        std::cout &lt;&lt; b.msg();
    }
}</pre></div>
<p>Что выводит данная программа? Почему? Как нужно её исправить, чтобы выводилось "derived"?</p><h2>Вопрос 20</h2>
<div class="codeblock"><pre>#include &lt;iostream&gt;

struct base
{
    virtual char const* msg() const
    {
        return "base";
    }
};

struct derived : base
{
    char const* msg() const
    {
        return "derived";
    }
};

void f()
{
    throw derived();
}

void g()
{
    try
    {
        f();
    }
    catch (base const&amp; b)
    {
        std::cout &lt;&lt; b.msg() &lt;&lt; '\n';
        throw b;
    }
}

int main()
{
    try
    {
        g();
    }
    catch (base const&amp; b)
    {
        std::cout &lt;&lt; b.msg();
    }
}
</pre></div>
<p>Что выводит данная программа? Почему? Как нужно её исправить, чтобы выводилось "derived\nderived"?</p><h2>Вопрос 21</h2>
<p>Почему такая реализации оператора присваивания у класса mystring является ошибочной?</p><div class="codeblock"><pre>mystring&amp; mystring::operator=(mystring const&amp; rhs)
{
    operator delete(data_);
    size_ = rhs.size_;
    capacity_ = size_;
    data_ = static_cast&lt;char*&gt;(operator new(rhs.size_ + 1));
    memcpy(data_, rhs.data_, rhs.size_ + 1);
    return *this;
}</pre></div>
<h2>Вопрос 22</h2>
<p>Что такое small-object оптимизация? Приведите примеры. В каких случаях она даёт выигрыш? В каких случаях она даёт проигрыш?</p><h2>Вопрос 23</h2>
<p>Напишите шаблонный класс (и, если нужно, специализации к нему), который позволяет получить общее число элементов у многомерного массива. В случае если передан не массив верните 1. То есть:</p><div class="codeblock"><pre>array_size&lt;int [10]&gt;::value == 10
array_size&lt;float [5][6]&gt;::value == 30
array_size&lt;double [5][6][7]&gt;::value == 210
array_size&lt;int* [5]&gt;::value == 5
array_size&lt;int&gt;::value == 1
array_size&lt;int*&gt;::value == 1</pre></div>
<h2>Вопрос 24</h2>
<p>Пусть необходимо реализовать функцию void f(T* data, size_t size) двумя способами в зависимости от того, является ли тип T знаковым или беззнаковым выбираемый во время компиляции программы.</p>

<p>Напишите реализацию такой функции используя
<ol><li>SFINAE</li>
<li>tag-dispathing</li></ol></p><h2>Вопрос 25</h2>
<p>Пусть необходимо реализовать класс mytype&lt;T&gt; двумя способами в зависимости от того, является ли тип T знаковым или беззнаковым выбираемый во время компиляции программы.</p>

<p>Напишите реализацию такого класса используя SFINAE.</p><h2>Вопрос 26</h2>
<p>Что такое анонимные неймпейсы? Для чего они нужны? Можно ли их писать в хедер файлах?</p>  </body>
</html>