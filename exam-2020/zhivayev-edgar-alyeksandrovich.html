<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Живаев Эдгар Александрович, Экзамен C++, 8 июля 2020</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <style type="text/css">
    .codeblock
    {
      background: #e0e0e0;
      border: solid 1px black;
      padding: 5px;
      font-family: monospace;
    }
    .codein
    {
      font-family: monospace;
    }
    pre { margin: 0; }
    td.numbers {text-align: right;}
    td.names {text-align: left;}
    td {text-align: center;}
    tr.odd {background-color: #e0e0e0;}
    img.centered {display: block; margin-left: auto; margin-right: auto;}
    sup:target {background-color: #def;}
    li:target {background-color: #def;}
    ol li { list-style-type: lower-russian; }
    p {font-family:sans-serif; font-size: 12pt;}
    p {font-family:'Liberation Sans', sans-serif; font-size: 12pt;}
    li {font-family:'Liberation Sans', sans-serif; font-size: 12pt;}
    h2 {font-family:'Liberation Sans', sans-serif;}
    h3 {font-family:'Liberation Sans', sans-serif;}
    h4 {font-family:'Liberation Sans', sans-serif;}
    </style>
  </head>
  <body>
<h2>Живаев Эдгар Александрович</h2>
<h2>Вопрос 1</h2>
<p>Какие значения получат регистры <span class="codein">bl</span>, <span class="codein">cl</span> после исполнения функции <span class="codein">foo</span>?</p>
<div class="codeblock"><pre>somevar:    dw 0

foo:
            mov ax, 0x1234
            mov [somevar], ax
            
            mov bl, [somevar]
            mov cl, [somevar + 1]

            ret</pre></div>
<h2>Вопрос 2</h2>
<p>Даны три инструкции:</p><div class="codeblock"><pre>            lea     rdi, [rdi + 8]
            mov     rdi, [rdi + 8]
            add     rdi, 8</pre></div>
<p>Опишите, что делает каждая из них. Чем поведение <span class="codein">lea</span> отличается от <span class="codein">mov</span>? Чем поведение <span class="codein">lea</span> отличается от <span class="codein">add</span>.</p>
<h2>Вопрос 3</h2>
<p>Напишите (на ассемблере) функцию вычисляющую <span class="codein">N</span>'ое число фибоначчи (mod 2<sup>64</sup>). <span class="codein">fib(0) = 0</span>, <span class="codein">fib(1) = 1</span>, <span class="codein">fib(n) = fib(n - 1) + fib(n - 2)</span>. Считайте, что при входе <span class="codein">N</span> записано в регистре <span class="codein">rdi</span>. При выходе ответ должен быть записан в <span class="codein">rax</span>.</p><h2>Вопрос 4</h2>
<p>Что такое соглашения вызова функций? Какие соглашения вызова функций вы знаете? Чем они отличаются друг от друга?</p><h2>Вопрос 5</h2>
<p>Пусть у нас есть функция <span class="codein">void foo(int, void*)</span>. Какой код необходимо сгенерить компилятору, чтобы вызвать эту функцию <span class="codein">f(42, nullptr)</span>, предполагая что программа компилируется под 64-битный Linux?</p><h2>Вопрос 6</h2>
<p>Зачем нужна страничная адресация?</p><h2>Вопрос 7</h2>
<p>Предполагая что программа скомпилирована для Linux 64-bit, чему равны <span class="codein">sizeof</span> и <span class="codein">alignof</span> следующих структур? Объясните почему.</p><div class="codeblock"><pre>struct s1
{
    int a;
    int b;
};

struct s2
{
    char a;
    int b;
};

struct s3
{
    int a;
    char b;
};

struct s4
{
    char a;
    int b;
    char c;
};

struct s5
{};

struct s6
{
    s5 x, y, z;
};

struct s7 : s5
{};

struct s8 : s5, s7
{};

struct t10
{
    virtual void foo();
};

struct t11 : t10
{
    virtual void bar();
};

struct t12 : virtual t10
{};</pre></div>
<h2>Вопрос 8</h2>
<p><ol><li>Чему равен минимальный <span class="codein">double</span> строго больший <span class="codein">1.</span>?</li>
<li>Чему равен минимальный <span class="codein">double</span> строго больший <span class="codein">2.</span>?</li></ol></p>
<h2>Вопрос 9</h2>
<p>Правда ли, что для floating-point чисел a != b влечёт (a - b) != 0?</p><h2>Вопрос 10</h2>
<p>(если в этом задании отвечаете нет, приведите контрпример)
    
    <ol><li>Правда ли, что для любых floating-point a и b верно a + b == b + a?</li>
    <li>Правда ли, что для любых floating-point a, b и c верно a + (b + c) == (a + b) + c?</li>
    <li>Правда ли, что для любого floating-point a верно 1 * a == a?</li>
    <li>Правда ли, что для любого floating-point a верно 0 * a == 0?</li>
    <li>Правда ли, что для любого floating-point a верно a - a == 0?</li></ol></p><h2>Вопрос 11</h2>
<p>Дана программа, состоящая из следующих файлов:</p><div class="codeblock"><pre>// main.cpp
#include "f.h"

int main()
{
    f();
    g();
}</pre></div>
<div class="codeblock"><pre>// f.h
#pragma once
#include &lt;iostream&gt;

void f()
{
    std::cout &lt;&lt; "hello";
}</pre></div>
<div class="codeblock"><pre>// g.cpp
#include "f.h"

void g()
{
    std::cout &lt;&lt; ' ';
    f();
}</pre></div>
<p>Скомпилируется ли данная программа? Если да, то что она выведет? Если нет, то какие в ней ошибки и как их можно исправить?</p><h2>Вопрос 12</h2>
<p>Пусть есть следующий заголовочный файл:</p><div class="codeblock"><pre>// sum.h
static int sum(int a, int b)
{
    return a + b;
}</pre></div>
<p>Какие вы видите ошибки в этом файле? Как их можно исправить?</p><h2>Вопрос 13</h2>
<p>В чем разница между директивами препроцессора #if и #ifdef?</p><h2>Вопрос 14</h2>
<p>Будем считать, что правильный оператор [], это такой, который ведет себя как [] у массива. Объясните почему такие операторы [] у mystring неправильные:</p><p><ol><li><span class="codein">char operator[](size_t i);</span> (одной перегрузкой)</li>
<li><span class="codein">char&amp; operator[](size_t i) const;</span> (одной перегрузкой)</li></ol></p><p>Напишите правильный набор перегрузок для оператор [] у класса mystring.</p><h2>Вопрос 15</h2>
<p>В чём разница между парами malloc/free, new T/delete p, operator new/operator delete?</p><h2>Вопрос 16</h2>
<p>Пусть есть следующая программа:</p><div class="codeblock"><pre>#include &lt;iostream&gt;

struct base
{
   virtual void foo();
};

struct derived : base
{
   void foo() override;
};

void derived::foo()
{
   std::cout &lt;&lt; "derived::foo\n";
   // call foo() in base
}</pre></div>
<p>Что нужно написать на месте комментария, чтобы вызвать foo() из базового класса?</p><h2>Вопрос 17</h2>
<p>Корректная ли это программа? Если корректная, то, что она выводит? Если некорректная, то, в чём заключается ошибка?</p><div class="codeblock"><pre>#include &lt;iostream&gt;

struct base
{
    base()
    {
        f();
    }
    
    void f()
    {
        g();
    }
    
    virtual void g() = 0;
};

struct derived : base
{
    void g()
    {
        std::cout &lt;&lt; "hello\n";
    }
};

int main()
{
    derived d;
}</pre></div>
<p>Почему программа выше и программа ниже ведут себя по-разному?</p><div class="codeblock"><pre>#include &lt;iostream&gt;

struct base
{
    base()
    {
        g();
    }
    
    virtual void g() = 0;
};

struct derived : base
{
    void g()
    {
        std::cout &lt;&lt; "hello\n";
    }
};

int main()
{
    derived d;
}</pre></div>
<h2>Вопрос 18</h2>
<div class="codeblock"><pre>struct base
{
    virtual ~base();
};

struct derived : virtual base
{};

void foo(base* b)
{
    static_cast&lt;derived*&gt;(b); // (1)
    dynamic_cast&lt;derived*&gt;(b); // (2)
}</pre></div>
<p>Компилируются ли (1) и (2)? Почему?</p><h2>Вопрос 19</h2>
<p><ol><li>Можно ли бросать исключения из деструктора? Если да, приведите пример.</li>
<li>Можно ли бросать исключения из конструктора? Если да, приведите пример.</li></ol></p><h2>Вопрос 20</h2>
<p>Почему такая реализации оператора присваивания у класса mystring является ошибочной?</p><div class="codeblock"><pre>mystring&amp; mystring::operator=(mystring const&amp; rhs)
{
    operator delete(data_);
    size_ = rhs.size_;
    capacity_ = size_;
    data_ = static_cast&lt;char*&gt;(operator new(rhs.size_ + 1));
    memcpy(data_, rhs.data_, rhs.size_ + 1);
    return *this;
}</pre></div>
<h2>Вопрос 21</h2>
<p>Напишите функцию <span class="codein">void erase_strong(std::vector&lt;T&gt;&amp; v, typename std::vector&lt;T&gt;::const_iterator pos)</span>, которая удаляет элемент на позиции pos из вектора v и удовлетворяет строгой гарантии безопасности исключений.</p><h2>Вопрос 22</h2>
<p>Что такое copy-on-write оптимизация? Приведите примеры. В каких случаях она даёт выигрыш? В каких случаях она даёт проигрыш?</p><h2>Вопрос 23</h2>
<p>Напишите шаблонный класс (и, если нужно, специализации к нему), который позволяет получить тип элемента у многомерного массива. В случае если передан не массив верните тип без изменения. То есть:</p><div class="codeblock"><pre>element_type&lt;int [10]&gt;::type == int
element_type&lt;float [5][6]&gt;::type == float
element_type&lt;double [5][6][7]&gt;::type == double
element_type&lt;int* [5]&gt;::type == int*
element_type&lt;int&gt;::type == int
element_type&lt;int*&gt;::type == int*</pre></div>
<h2>Вопрос 24</h2>
<p>Пусть необходимо реализовать класс mytype&lt;T&gt; двумя способами в зависимости от того, является ли тип T знаковым или беззнаковым выбираемый во время компиляции программы.</p>

<p>Напишите реализацию такого класса используя SFINAE.</p><h2>Вопрос 25</h2>
<p>Что такое зависимые имена? Что означает ключевое слово typename стоящее перед зависимым именем? Что означает ключевое слово template стоящее перед зависимым именем?</p><h2>Вопрос 26</h2>
<p>Что такое анонимные неймпейсы? Для чего они нужны? Можно ли их писать в хедер файлах?</p>  </body>
</html>